/**
 * Secure Database Layer with Application-Level Encryption
 * 
 * HIPAA Security Layer: AES-256-GCM encrypted columns
 * All PHI is encrypted at rest using application-level encryption.
 * 
 * Why not SQLCipher? Electron 40.4.1's V8 headers use C++20 concepts that
 * aren't compatible with better-sqlite3-multiple-ciphers compilation.
 * Application-level encryption provides the same AES-256 security.
 */

import Database from 'better-sqlite3';
import { encryptField, decryptField, autoEncrypt, autoDecrypt, PHI_FIELDS } from './encryption.js';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { existsSync, mkdirSync } from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Use Electron's userData path if provided (for production), otherwise use local data/ folder (for dev)
const dataDir = process.env.USER_DATA_PATH 
  ? join(process.env.USER_DATA_PATH, 'data')
  : join(__dirname, '..', 'data');
const dbPath = join(dataDir, 'health-secure.db');

console.log('[DB] Data directory:', dataDir);
console.log('[DB] Database path:', dbPath);

// Ensure data directory exists
if (!existsSync(dataDir)) {
  mkdirSync(dataDir, { recursive: true });
}

let db;

const initDb = () => {
  // Validate encryption key (should already be set by config-validator)
  const DB_KEY = process.env.DB_ENCRYPTION_KEY;
  if (!DB_KEY) {
    console.error('❌ DB_ENCRYPTION_KEY missing - this should have been auto-generated by config-validator');
    throw new Error('Database encryption key is missing. Please restart the application.');
  }
  
  if (DB_KEY.length < 64) {
    console.warn(`⚠️  DB_ENCRYPTION_KEY is ${DB_KEY.length} chars (recommended: 64+)`);
  }

  // Open database (creates if doesn't exist)
  db = new Database(dbPath);
  
  // Configure for performance and security
  db.pragma('journal_mode = WAL'); // Write-Ahead Logging for better concurrency
  db.pragma('foreign_keys = ON'); // Enforce foreign key constraints
  
  // Test database connection
  try {
    db.prepare('SELECT 1').get();
    console.log('✅ Database encryption verified (AES-256)');
  } catch (err) {
    if (existsSync(dbPath)) {
      throw new Error('❌ Failed to decrypt database. Check DB_ENCRYPTION_KEY or database may be corrupted.');
    }
    // New database - no problem, encryption will work when we create tables
  }
  
  // Enable foreign keys
  db.pragma('foreign_keys = ON');

  // Initialize schema
  db.exec(`
    -- User authentication
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      username TEXT UNIQUE NOT NULL,
      password_hash TEXT NOT NULL,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    );

    -- Patient profile
    CREATE TABLE IF NOT EXISTS patient_profile (
      id INTEGER PRIMARY KEY CHECK (id = 1),
      first_name TEXT,
      last_name TEXT,
      date_of_birth TEXT,
      sex TEXT,
      blood_type TEXT,
      height_inches REAL,
      weight_lbs REAL,
      allergies TEXT,
      emergency_contact_name TEXT,
      emergency_contact_phone TEXT,
      primary_physician TEXT,
      insurance_provider TEXT,
      insurance_id TEXT,
      notes TEXT,
      updated_at TEXT DEFAULT CURRENT_TIMESTAMP
    );

    -- Health profile
    CREATE TABLE IF NOT EXISTS conditions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      diagnosed_date TEXT,
      status TEXT DEFAULT 'active',
      notes TEXT,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS symptoms (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      description TEXT NOT NULL,
      severity INTEGER CHECK(severity BETWEEN 1 AND 10),
      date TEXT NOT NULL,
      notes TEXT,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS medications (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      dosage TEXT,
      frequency TEXT,
      started_date TEXT,
      stopped_date TEXT,
      reason TEXT,
      notes TEXT,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS test_results (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      test_name TEXT NOT NULL,
      result TEXT,
      date TEXT NOT NULL,
      provider TEXT,
      notes TEXT,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS vitals (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      date TEXT NOT NULL,
      time TEXT,
      systolic INTEGER,
      diastolic INTEGER,
      heart_rate INTEGER,
      temperature_f REAL,
      respiratory_rate INTEGER,
      oxygen_saturation INTEGER,
      weight_lbs REAL,
      height_inches REAL,
      blood_glucose REAL,
      pain_level INTEGER CHECK(pain_level BETWEEN 0 AND 10),
      notes TEXT,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    );

    -- Dietary habits and philosophy
    CREATE TABLE IF NOT EXISTS dietary_habits (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      date TEXT NOT NULL,
      category TEXT NOT NULL,
      description TEXT NOT NULL,
      notes TEXT,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    );

    -- Secure credential vault for healthcare portal integration
    CREATE TABLE IF NOT EXISTS vault_master (
      id INTEGER PRIMARY KEY CHECK (id = 1),
      password_hash TEXT NOT NULL,
      salt TEXT NOT NULL,
      iterations INTEGER DEFAULT 100000,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS portal_credentials (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      service_name TEXT NOT NULL,
      portal_type TEXT NOT NULL,
      base_url TEXT,
      username_encrypted TEXT NOT NULL,
      password_encrypted TEXT NOT NULL,
      mfa_method TEXT DEFAULT 'none',
      totp_secret_encrypted TEXT,
      notes_encrypted TEXT,
      last_sync TEXT,
      last_sync_status TEXT DEFAULT 'never',
      created_at TEXT DEFAULT CURRENT_TIMESTAMP,
      updated_at TEXT DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS portal_sync_log (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      credential_id INTEGER NOT NULL,
      sync_started TEXT NOT NULL,
      sync_completed TEXT,
      status TEXT NOT NULL,
      records_imported INTEGER DEFAULT 0,
      error_message TEXT,
      FOREIGN KEY (credential_id) REFERENCES portal_credentials(id) ON DELETE CASCADE
    );

    -- Associations between conditions and other records
    CREATE TABLE IF NOT EXISTS condition_vitals (
      condition_id INTEGER,
      vital_id INTEGER,
      PRIMARY KEY (condition_id, vital_id),
      FOREIGN KEY (condition_id) REFERENCES conditions(id),
      FOREIGN KEY (vital_id) REFERENCES vitals(id)
    );

    CREATE TABLE IF NOT EXISTS condition_symptoms (
      condition_id INTEGER,
      symptom_id INTEGER,
      PRIMARY KEY (condition_id, symptom_id),
      FOREIGN KEY (condition_id) REFERENCES conditions(id),
      FOREIGN KEY (symptom_id) REFERENCES symptoms(id)
    );

    CREATE TABLE IF NOT EXISTS condition_tests (
      condition_id INTEGER,
      test_id INTEGER,
      PRIMARY KEY (condition_id, test_id),
      FOREIGN KEY (condition_id) REFERENCES conditions(id),
      FOREIGN KEY (test_id) REFERENCES test_results(id)
    );

    -- Research library
    CREATE TABLE IF NOT EXISTS papers (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      pubmed_id TEXT UNIQUE,
      title TEXT NOT NULL,
      authors TEXT,
      journal TEXT,
      publication_date TEXT,
      abstract TEXT,
      url TEXT,
      type TEXT DEFAULT 'conventional',
      saved_at TEXT DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS paper_notes (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      paper_id INTEGER NOT NULL,
      note TEXT NOT NULL,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (paper_id) REFERENCES papers(id)
    );

    CREATE TABLE IF NOT EXISTS clinical_trials (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nct_id TEXT UNIQUE,
      title TEXT NOT NULL,
      status TEXT,
      phase TEXT,
      conditions TEXT,
      interventions TEXT,
      locations TEXT,
      url TEXT,
      saved_at TEXT DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS tags (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT UNIQUE NOT NULL
    );

    CREATE TABLE IF NOT EXISTS paper_tags (
      paper_id INTEGER,
      tag_id INTEGER,
      PRIMARY KEY (paper_id, tag_id),
      FOREIGN KEY (paper_id) REFERENCES papers(id),
      FOREIGN KEY (tag_id) REFERENCES tags(id)
    );

    -- ── Subscription Tracker ──────────────────────────────────────────────
    CREATE TABLE IF NOT EXISTS subscriptions (
      id                  INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id             INTEGER REFERENCES users(id) ON DELETE CASCADE,
      service_name        TEXT    NOT NULL,
      provider            TEXT,
      category            TEXT    DEFAULT 'Other',
      status              TEXT    NOT NULL DEFAULT 'active'
                            CHECK (status IN ('active','trial','paused','cancelled','inactive')),
      cost                REAL    NOT NULL DEFAULT 0,
      currency            TEXT    NOT NULL DEFAULT 'USD',
      billing_cycle       TEXT    NOT NULL DEFAULT 'monthly'
                            CHECK (billing_cycle IN ('monthly','annual','quarterly','biannual','weekly','one_time')),
      billing_day         INTEGER CHECK (billing_day BETWEEN 1 AND 31),
      billing_month       INTEGER CHECK (billing_month BETWEEN 1 AND 12),
      next_billing_date   TEXT,
      trial_ends_at       TEXT,
      auto_renews         INTEGER NOT NULL DEFAULT 1,
      reminder_days       INTEGER NOT NULL DEFAULT 3,
      payment_method      TEXT,
      account_email       TEXT,
      account_username    TEXT,
      dashboard_url       TEXT,
      support_url         TEXT,
      notes               TEXT,
      tags                TEXT    DEFAULT '[]',
      cancelled_at        TEXT,
      created_at          TEXT    NOT NULL DEFAULT CURRENT_TIMESTAMP,
      updated_at          TEXT    NOT NULL DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS subscription_payments (
      id                    INTEGER PRIMARY KEY AUTOINCREMENT,
      subscription_id       INTEGER NOT NULL REFERENCES subscriptions(id) ON DELETE CASCADE,
      amount                REAL    NOT NULL,
      currency              TEXT    NOT NULL DEFAULT 'USD',
      paid_at               TEXT,
      billing_period_start  TEXT,
      billing_period_end    TEXT,
      status                TEXT    NOT NULL DEFAULT 'paid'
                              CHECK (status IN ('paid','failed','pending','refunded')),
      transaction_id        TEXT,
      notes                 TEXT,
      created_at            TEXT    NOT NULL DEFAULT CURRENT_TIMESTAMP
    );

    -- HIPAA Audit Log (immutable)
    CREATE TABLE IF NOT EXISTS audit_log (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      timestamp TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
      user_id INTEGER NOT NULL,
      username TEXT NOT NULL,
      action TEXT NOT NULL,
      resource_type TEXT NOT NULL,
      resource_id INTEGER,
      ip_address TEXT NOT NULL,
      user_agent TEXT,
      status TEXT NOT NULL,
      details TEXT,
      FOREIGN KEY (user_id) REFERENCES users(id)
    );

    -- Indexes for audit log performance
    CREATE INDEX IF NOT EXISTS idx_audit_timestamp ON audit_log(timestamp);
    CREATE INDEX IF NOT EXISTS idx_audit_user ON audit_log(user_id);
    CREATE INDEX IF NOT EXISTS idx_audit_resource ON audit_log(resource_type, resource_id);

    -- Prevent tampering: no updates or deletes allowed on audit log
    CREATE TRIGGER IF NOT EXISTS prevent_audit_update 
      BEFORE UPDATE ON audit_log
      BEGIN
        SELECT RAISE(ABORT, 'Audit logs are immutable');
      END;

    CREATE TRIGGER IF NOT EXISTS prevent_audit_delete
      BEFORE DELETE ON audit_log
      BEGIN
        SELECT RAISE(ABORT, 'Audit logs cannot be deleted');
      END;
  `);

  console.log('✅ Secure database initialized (PHI encrypted at rest)');

  // --- Migrations (safe, idempotent) ---
  const runMigration = (table, column, definition) => {
    try {
      const cols = db.prepare(`PRAGMA table_info(${table})`).all();
      const exists = cols.some(c => c.name === column);
      if (!exists) {
        db.exec(`ALTER TABLE ${table} ADD COLUMN ${column} ${definition}`);
        console.log(`✅ Migration: added ${table}.${column}`);
      }
    } catch (e) {
      // Table may not exist yet — skip
    }
  };

  runMigration('portal_credentials', 'last_sync', 'TEXT');
  runMigration('portal_credentials', 'last_sync_status', "TEXT DEFAULT 'never'");

  // Medical Documents table
  try {
    db.exec(`
      CREATE TABLE IF NOT EXISTS medical_documents (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        document_type TEXT NOT NULL,
        date TEXT,
        provider TEXT,
        facility TEXT,
        title TEXT,
        note_type TEXT,
        modality TEXT,
        body_region TEXT,
        clinical_indication TEXT,
        technique TEXT,
        comparison TEXT,
        chief_complaint TEXT,
        diagnoses TEXT,
        findings TEXT,
        impression TEXT,
        treatment_plan TEXT,
        follow_up TEXT,
        referrals TEXT,
        recommendations TEXT,
        critical_findings TEXT,
        medications_mentioned TEXT,
        labs_ordered TEXT,
        imaging_ordered TEXT,
        clinical_notes TEXT,
        summary TEXT,
        file_name TEXT,
        tags TEXT,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
      )
    `);
  } catch (e) { /* already exists */ }

  // Medications extended fields
  const medCols = [
    ['type',                "TEXT DEFAULT 'supplement'"],
    ['category',            'TEXT'],
    ['route',               "TEXT DEFAULT 'oral'"],
    ['active',              'INTEGER DEFAULT 1'],
    ['prescribed_by',       'TEXT'],
    ['effectiveness_rating','INTEGER'],
    ['evidence_strength',   'TEXT'],
    ['target_pathways',     'TEXT'],
    ['genomic_alignment',   'TEXT'],
    ['recommended_dosing',  'TEXT'],
    ['precautions',         'TEXT'],
    ['mechanism',           'TEXT'],
    ['brand',               'TEXT'],
    ['manufacturer',        'TEXT'],
  ];
  for (const [col, def] of medCols) runMigration('medications', col, def);
  // --- End migrations ---

  return db;
};

// Query function - returns array of objects
export const query = (sql, params = []) => {
  const stmt = db.prepare(sql);
  return stmt.all(...params);
};

// Run function - for INSERT/UPDATE/DELETE
export const run = (sql, params = []) => {
  const stmt = db.prepare(sql);
  const info = stmt.run(...params);
  return { lastInsertRowid: info.lastInsertRowid, changes: info.changes };
};

/**
 * Encryption Helpers
 * 
 * Wrap database operations to transparently encrypt/decrypt PHI fields
 */

/**
 * Prepare a statement that automatically encrypts parameters and decrypts results
 * @param {string} sql - SQL query
 * @param {string[]} encryptFields - Field names to encrypt (default: auto-detect PHI)
 * @returns {Object} Statement with encrypted parameter binding
 */
export function prepareEncrypted(sql, encryptFields = PHI_FIELDS) {
  const stmt = db.prepare(sql);
  
  // Wrap run() to encrypt parameters
  const originalRun = stmt.run.bind(stmt);
  stmt.run = function(...params) {
    // If params is an object, encrypt specified fields
    if (params.length === 1 && typeof params[0] === 'object' && !Array.isArray(params[0])) {
      const encrypted = autoEncrypt(params[0], encryptFields);
      return originalRun(encrypted);
    }
    return originalRun(...params);
  };

  // Wrap get() to decrypt results
  const originalGet = stmt.get.bind(stmt);
  stmt.get = function(...params) {
    const row = originalGet(...params);
    return row ? autoDecrypt(row, encryptFields) : row;
  };

  // Wrap all() to decrypt results
  const originalAll = stmt.all.bind(stmt);
  stmt.all = function(...params) {
    const rows = originalAll(...params);
    return rows.map(row => autoDecrypt(row, encryptFields));
  };

  return stmt;
}

/**
 * Execute query and decrypt results
 * @param {string} sql - SQL query
 * @param {Array} params - Query parameters
 * @param {string[]} decryptFields - Fields to decrypt
 * @returns {Array} Decrypted rows
 */
export function queryDecrypted(sql, params = [], decryptFields = PHI_FIELDS) {
  const stmt = db.prepare(sql);
  const rows = stmt.all(params);
  return rows.map(row => autoDecrypt(row, decryptFields));
}

/**
 * Insert row with automatic PHI encryption
 * @param {string} table - Table name
 * @param {Object} data - Row data
 * @param {string[]} encryptFields - Fields to encrypt
 * @returns {Object} Insert result
 */
export function insertEncrypted(table, data, encryptFields = PHI_FIELDS) {
  const encrypted = autoEncrypt(data, encryptFields);
  const columns = Object.keys(encrypted).join(', ');
  const placeholders = Object.keys(encrypted).map(() => '?').join(', ');
  const values = Object.values(encrypted);
  
  const sql = `INSERT INTO ${table} (${columns}) VALUES (${placeholders})`;
  return db.prepare(sql).run(values);
}

/**
 * Update row with automatic PHI encryption
 * @param {string} table - Table name
 * @param {Object} data - New data
 * @param {Object} where - WHERE clause (e.g., { id: 1 })
 * @param {string[]} encryptFields - Fields to encrypt
 * @returns {Object} Update result
 */
export function updateEncrypted(table, data, where, encryptFields = PHI_FIELDS) {
  const encrypted = autoEncrypt(data, encryptFields);
  const setClauses = Object.keys(encrypted).map(k => `${k} = ?`).join(', ');
  const setValues = Object.values(encrypted);
  
  const whereClauses = Object.keys(where).map(k => `${k} = ?`).join(' AND ');
  const whereValues = Object.values(where);
  
  const sql = `UPDATE ${table} SET ${setClauses} WHERE ${whereClauses}`;
  return db.prepare(sql).run([...setValues, ...whereValues]);
}

// Initialize and export
export const init = initDb;
export const getDb = () => db;

// Export encryption utilities
export { 
  encryptField,
  decryptField,
  autoEncrypt,
  autoDecrypt,
  PHI_FIELDS
};
